* DONE read_{start,stop}
yuck.  just always stop when getting the read callaback, hopefully not
very expensive.

maybe massage the callback further to do the duty of alloc_cb too (and
pass a no-op alloc_cb)?  ergonomics!
* DONE make provision to put magic code in callbacks
so can /see above/
* DONE expose specific co destructuring
so can access state etc. reasonably conveniently not just in the coro
itself (like in an alloc_cb or w/e).

also maybe force user to choose names for args, state, etc.
* DONE prevent errant returns
coros return void so it's very easy to just return by mistake (not
co_return).  maybe add a runtime guard, like a scope guard that checks
that either we are truly out or we leave a pending nested promise
behind.

try to improve this, like store the function name at least?
* DONE keep nested promises around longer
to avoid the footgun waiting in using the previous result in next
call's parameters
* DONE more checking
* DONE find out more about the repeated-callback things
like is it actually lossless to stop/start tcp reads?  also maybe it's
fine to stop fs watchers after all?  but fuck signals in any case.
* DONE offload promise management to user
the nested promise magic is consy, hacky, and at all that not magical
enough.
* DONE now make uv promises built-in, with result union
lol
* TODO split coro structs into descriptors and instances
will make it possible to check type soundness with one pointer
comparison, for example.  will finally have to create a .c file
though, sad.
* TODO the listen situation
not only does it fire the callback multiple times with no way to cork,
it is not quite clear how to put any backpressure on it.  I guess the
second parameter to listen(2) is it?  does it cork until previous
listens are accept()'ed, or something else?

if the second parameter is the way, then need to implement a
uv_listener thingie etc., which will have to wait for the h/c split.
* TODO uv cancellation & closing
Those themselves have to be async and they are on the cleanup path,
argh
* think about events & other inter-coro comms
or maybe don't, yet (until a clear need materializes).  channels or
whatever is totally doable on top.
