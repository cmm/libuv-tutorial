* DONE read_{start,stop}
yuck.  just always stop when getting the read callaback, hopefully not
very expensive.

maybe massage the callback further to do the duty of alloc_cb too (and
pass a no-op alloc_cb)?  ergonomics!
* DONE make provision to put magic code in callbacks
so can /see above/
* DONE expose specific co destructuring
so can access state etc. reasonably conveniently not just in the coro
itself (like in an alloc_cb or w/e).

also maybe force user to choose names for args, state, etc.
* DONE prevent errant returns
coros return void so it's very easy to just return by mistake (not
co_return).  maybe add a runtime guard, like a scope guard that checks
that either we are truly out or we leave a pending nested promise
behind.

try to improve this, like store the function name at least?
* DONE keep nested promises around longer
to avoid the footgun waiting in using the previous result in next
call's parameters
* DONE more checking
* TODO find out more about the repeated-callback things
like is it actually lossless to stop/start tcp reads?  also maybe it's
fine to stop fs watchers after all?  but fuck signals in any case.
* TODO split coro structs into descriptors and instances
will make it possible to check type soundness with one pointer
comparison, for example.  will finally have to create a .c file
though, sad.
* TODO uv cancellation & closing
Those themselves have to be async and they are on the cleanup path,
argh
* think about events & other inter-coro comms
or maybe don't, yet (until a clear need materializes).  channels or
whatever is totally doable on top.
